# Java Development Kit (семинары)

## Урок 5. Многопоточность

1. Пять безмолвных философов сидят вокруг круглого стола, перед каждым философом стоит тарелка спагетти.
2. Вилки лежат на столе между каждой парой ближайших философов.
3. Каждый философ может либо есть, либо размышлять.
4. Философ может есть только тогда, когда держит две вилки — взятую справа и слева.
5. Философ не может есть два раза подряд, не прервавшись на размышления (можно не учитывать)
6. Философ может взять только две вилки сразу, то есть обе вилки должны быть свободны

Описать в виде кода такую ситуацию. Каждый философ должен поесть три раза

Чтобы избежать deadlock в данной задаче, можно использовать таймауты при попытках взять вилки и возвратить их в 
исходное состояние, если они не были взяты в течение определенного времени.
Философ сначала попробует взять левую вилку, и если у него это получится, то он попробует взять правую вилку. 
Если он не сможет взять обе вилки в течение определенного времени, то он положит обе вилки и повторит попытку позже. 
Это уменьшает вероятность deadlock.

Используем механизм блокировок (ReentrantLock) и метод tryLock() для избегания блокировок потоков.
- Каждая вилка (Fork) создается с собственным экземпляром блокировки (ReentrantLock).
- Когда философ пытается взять вилку, он вызывает метод pickUp(). 
Этот метод пытается заблокировать вилку, используя tryLock(). 
Если вилка доступна (не заблокирована другим философом), tryLock() вернет true, и философ сможет взять вилку. 
Если вилка уже заблокирована другим философом, tryLock() вернет false.
- Если философ успешно взял обе вилки (левую и правую), он выполняет действие "еда".
- После того как философ завершает еду, он вызывает метод putDown(), 
который разблокирует вилки, позволяя другим философам взять их.

Этот механизм обеспечивает отсутствие блокировок, так как tryLock() позволяет философам попробовать взять вилку, 
и если она уже занята, они просто не заблокируются и могут продолжать выполнение, что позволит избежать ситуаций, 
когда все философы блокируются, пытаясь взять вилки одновременно.

Таким образом, благодаря использованию tryLock(), потоки философов не блокируются и могут конкурировать 
за доступ к вилкам, предотвращая deadlock.